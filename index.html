<!doctype html>
<html lang=es>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Galaxia del Amor</title>
<style>body,html{margin:0;height:100%;background:#000;overflow:hidden}canvas{display:block}.player{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);width:90%;max-width:600px;display:flex;align-items:center;gap:10px;padding:10px;border:2px solid #f60;border-radius:999px;background:0 0;box-shadow:0 0 15px #f60,0 0 30px #f30;z-index:1000;font-family:Arial,sans-serif;color:#fff;font-size:14px}.player button{background:0 0;border:none;color:#fff;font-size:22px;cursor:pointer;filter:drop-shadow(0 0 6px #ff6600);transition:transform .2s}.player button:hover{transform:scale(1.2);filter:drop-shadow(0 0 10px #ff3300)}.progress{flex-grow:1;height:14px;background:rgba(255,255,255,.12);border-radius:999px;overflow:hidden;cursor:pointer;position:relative}.progress-bar{height:100%;width:0%;background:linear-gradient(270deg,#f60,#f30,#f09,#f60);background-size:400% 400%;border-radius:999px;box-shadow:0 0 10px #f60;animation:flowing 6s ease infinite}@keyframes flowing{0%{background-position:0 50%}50%{background-position:100% 50%}100%{background-position:0 50%}}.time{min-width:74px;text-align:right;font-size:12px;color:#fff;text-shadow:0 0 5px #f60}</style>
</head>
<body>
<canvas id=c></canvas>
<div class=player>
<button id=play>▶️</button>
<div class=progress id=progress><div class=progress-bar id=progress-bar></div></div>
<div class=time id=time>0:00 / 0:00</div>
</div>
<audio id=audio loop>
<source src="anhthuongemnhatma.mp3" type=audio/mpeg>
</audio>
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
<script>
/* === Giữ nguyên logic gốc (play, progress, renderer, scene, camera, effects...) === */
const audio=document.getElementById("audio"),
      playBtn=document.getElementById("play"),
      progress=document.getElementById("progress"),
      progressBar=document.getElementById("progress-bar"),
      timeDisplay=document.getElementById("time");
let isPlaying=!1;
function formatTime(e){if(!isFinite(e))return"0:00";return Math.floor(e/60)+":"+Math.floor(e%60).toString().padStart(2,"0")}
playBtn.addEventListener("click",(async()=>{
  if(isPlaying){ audio.pause(); playBtn.textContent="▶️"; }
  else { await audio.play(); playBtn.textContent="⏸️"; }
  isPlaying=!isPlaying;
}));
audio.addEventListener("timeupdate",(()=>{
  const e = audio.currentTime / audio.duration * 100;
  progressBar.style.width = (isFinite(e)? e : 0) + "%";
  timeDisplay.textContent = formatTime(audio.currentTime) + " / " + formatTime(audio.duration);
}));
progress.addEventListener("click",(e=>{
  const t = progress.getBoundingClientRect(), n = (e.clientX - t.left) / t.width;
  isFinite(audio.duration) && (audio.currentTime = n * audio.duration);
}));

/* Three setup */
const canvas = document.getElementById("c"),
      renderer = new THREE.WebGLRenderer({canvas:canvas,antialias:!0});
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(innerWidth,innerHeight);

const scene = new THREE.Scene(),
      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 5e3);

let targetDist=300, currentDist=300, rotX=.2, rotY=0;

const loader = new THREE.TextureLoader();
loader.crossOrigin = ''; // giúp load ảnh từ CDN nếu cần
const nebulaTex = loader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/space/px.jpg");
scene.background = nebulaTex;

/* Stars */
(function(e=2000,t=3000){
  const geo = new THREE.BufferGeometry(), arr = new Float32Array(3*e);
  for(let i=0;i<e;i++){
    const r = t*(.3+.7*Math.random()), a = Math.random()*Math.PI*2, b = Math.acos(2*Math.random()-1);
    arr[3*i+0] = r*Math.sin(b)*Math.cos(a);
    arr[3*i+1] = r*Math.cos(b);
    arr[3*i+2] = r*Math.sin(b)*Math.sin(a);
  }
  geo.setAttribute("position", new THREE.BufferAttribute(arr,3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({size:1.5, color:0xffffff, depthWrite:!1})));
})();

/* Core, center text, glow, rings (giữ nguyên) */
const coreMat = new THREE.MeshPhongMaterial({color:1118481,transparent:!0,opacity:.6,shininess:200});
const core = new THREE.Mesh(new THREE.SphereGeometry(40,64,64), coreMat); scene.add(core);

function makeCenterTextTexture(txt){
  const cvs = document.createElement("canvas"); cvs.width=512; cvs.height=512;
  const ctx = cvs.getContext("2d");
  ctx.clearRect(0,0,cvs.width,cvs.height);
  ctx.font="bold 80px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillStyle="#ff0033"; ctx.shadowColor="#ff66aa"; ctx.shadowBlur=50;
  ctx.fillText(txt, cvs.width/2, cvs.height/2);
  return new THREE.CanvasTexture(cvs);
}
const centerTex = makeCenterTextTexture("TE AMO ❤️");
const centerSprite = new THREE.Sprite(new THREE.SpriteMaterial({map:centerTex, transparent:!0}));
centerSprite.scale.set(60,60,1); centerSprite.position.set(0,0,0); scene.add(centerSprite);

function makeGlow(e=768,t="255,160,0",n="255,60,0"){
  const cvs=document.createElement("canvas"); cvs.width=cvs.height=e;
  const ctx=cvs.getContext("2d"), g=ctx.createRadialGradient(e/2,e/2,.05*e,e/2,e/2,.5*e);
  g.addColorStop(0,"rgba("+t+",0.9)"); g.addColorStop(.5,"rgba("+n+",0.5)"); g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle=g; ctx.fillRect(0,0,e,e);
  return new THREE.CanvasTexture(cvs);
}
const glow = new THREE.Sprite(new THREE.SpriteMaterial({map:makeGlow(), transparent:!0, depthWrite:!1}));
glow.scale.set(500,500,1); scene.add(glow);

function ringTexture(e=768){
  const cvs=document.createElement("canvas"); cvs.width=cvs.height=e;
  const ctx=cvs.getContext("2d"); ctx.translate(e/2,e/2);
  const a = .34*e, b = .49*e, g = ctx.createRadialGradient(0,0,.3*a,0,0,b);
  g.addColorStop(0,"rgba(255,255,200,1)"); g.addColorStop(.3,"rgba(255,160,60,0.9)");
  g.addColorStop(.65,"rgba(255,80,0,0.6)"); g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,b,0,2*Math.PI); ctx.arc(0,0,a,0,2*Math.PI,!0); ctx.closePath(); ctx.fill();
  return new THREE.CanvasTexture(cvs);
}
const ring1 = new THREE.Mesh(new THREE.RingGeometry(60,80,128), new THREE.MeshBasicMaterial({map:ringTexture(), transparent:!0, side:THREE.DoubleSide}));
const ring2 = new THREE.Mesh(new THREE.RingGeometry(85,100,128), new THREE.MeshBasicMaterial({map:ringTexture(), transparent:!0, side:THREE.DoubleSide, opacity:.6}));
ring1.rotation.x = ring2.rotation.x = Math.PI/2; scene.add(ring1); scene.add(ring2);

/* === Words (original correct approach) === */
const WORDS = [];
const baseWords = [
"Thương Em",
"Nhớ Em",
"Yêu Em",
"Miss You",
"Love You",
"Trọng Nghĩa",
"Bo",
"17-5-2009",
"Mê Em",
"Thích Em",
"TT: dtn1759_",
"buff MXH",
"LocketGold",
"CapCutPro",
"Nhiều Premium",
"Làm Website"
];
// nhân bản baseWords 6 lần (như ý bạn ban đầu)
for(let i=0;i<6;i++) WORDS.push(...baseWords);

function makeTextTexture(txt, shadowColor){
  const cvs=document.createElement("canvas"); cvs.width=512; cvs.height=128;
  const ctx=cvs.getContext("2d"); ctx.clearRect(0,0,cvs.width,cvs.height);
  ctx.font="bold 60px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillStyle="#fff"; ctx.shadowColor = shadowColor; ctx.shadowBlur = 30;
  ctx.fillText(txt, cvs.width/2, cvs.height/2);
  return new THREE.CanvasTexture(cvs);
}

const COLORS = ["#ff66ff","#66ccff","#ffd36b","#ff9966","#8df59a","#ffa0f8","#c6a7ff","#ff4444","#44ff99","#99ccff"];
const textGroup = new THREE.Group(); scene.add(textGroup);

/* === Image group để chứa ảnh nhỏ kế bên mỗi tên === */
const imageGroup = new THREE.Group(); scene.add(imageGroup);

/* Thay bằng link ảnh của bạn nếu muốn */
const IMAGE_LINKS = [
 "a1.png",
 "a2.png",
 "a3.png",
 "a4.png",
 "a5.png"
];

for(let idx=0; idx<WORDS.length; idx++){
  const txtTex = makeTextTexture(WORDS[idx], COLORS[idx % COLORS.length]);
  const txtMat = new THREE.SpriteMaterial({map: txtTex, transparent: !0});
  const txtSprite = new THREE.Sprite(txtMat);
  txtSprite.scale.set(50,16,1);

  const phi = Math.acos(2*Math.random()-1);
  const theta = Math.random()*Math.PI*2;
  const radius = 150 + 120*Math.random();
  txtSprite.position.set(radius*Math.sin(phi)*Math.cos(theta), radius*Math.cos(phi), radius*Math.sin(phi)*Math.sin(theta));
  txtSprite.userData = {phi: phi, theta: theta, radius: radius, speed: .001 + .001*Math.random()};
  textGroup.add(txtSprite);

  // ảnh tương ứng: dùng modulo để không cần đủ ảnh cho mọi tên
  const imgUrl = IMAGE_LINKS[idx % IMAGE_LINKS.length];
  const imgTex = loader.load(imgUrl);
  const imgMat = new THREE.SpriteMaterial({map: imgTex, transparent: !0});
  const imgSprite = new THREE.Sprite(imgMat);
  imgSprite.scale.set(20,20,1);

  // đặt ảnh ban đầu lệch sang phải (offset) so với vị trí text
  const offset = 25;
  imgSprite.position.set(txtSprite.position.x + offset, txtSprite.position.y, txtSprite.position.z);
  imgSprite.userData = {phi: phi, theta: theta, radius: radius, speed: txtSprite.userData.speed, offset: offset};
  imageGroup.add(imgSprite);
}

/* Controls: giữ nguyên thao tác chuột & chạm & pinch & wheel */
let dragging = !1, lastX = 0, lastY = 0;
function onDown(e){ dragging = !0; const t = e.touches ? e.touches[0] : e; lastX = t.clientX; lastY = t.clientY; }
function onMove(e){ if(!dragging) return; const t = e.touches ? e.touches[0] : e, nx = (t.clientX - lastX)/innerWidth, ny = (t.clientY - lastY)/innerHeight; rotY -= 3*nx; rotX = Math.max(-1.2, Math.min(1.2, rotX - 2.2*ny)); lastX = t.clientX; lastY = t.clientY; }
function onUp(){ dragging = !1; }
addEventListener("mousedown", onDown); addEventListener("mousemove", onMove); addEventListener("mouseup", onUp);
addEventListener("touchstart", onDown, {passive:!0}); addEventListener("touchmove", onMove, {passive:!0}); addEventListener("touchend", onUp, {passive:!0});
addEventListener("wheel", (e=>{ targetDist += .25*e.deltaY; targetDist = Math.max(160, Math.min(600, targetDist)); }), {passive:!0});

let pinch = 0;
addEventListener("touchmove", (e=>{
  if(e.touches && e.touches.length === 2){
    e.preventDefault();
    const dx = e.touches[0].clientX - e.touches[1].clientX,
          dy = e.touches[0].clientY - e.touches[1].clientY,
          dist = Math.hypot(dx,dy);
    if(pinch) { targetDist += .5*(pinch - dist); targetDist = Math.max(160, Math.min(600, targetDist)); }
    pinch = dist;
  }
}), {passive:!1});
addEventListener("touchend", (()=>{ pinch = 0; }), {passive:!0});

/* Animation loop */
let t = 0;
function tick(){
  requestAnimationFrame(tick);
  t += .01;
  ring1.rotation.z += .002;
  ring2.rotation.z -= .0015;
  glow.scale.set(500*(1+.03*Math.sin(.4*t)), 500*(1+.03*Math.sin(.4*t)), 1);
  const e = 1 + .05*Math.sin(3*t);
  core.scale.set(e,e,e);

  // update chữ
  textGroup.children.forEach(spr => {
    spr.material.opacity = .8 + .2*Math.sin(2*t);
    spr.userData.theta += spr.userData.speed;
    spr.position.x = spr.userData.radius*Math.sin(spr.userData.phi)*Math.cos(spr.userData.theta);
    spr.position.z = spr.userData.radius*Math.sin(spr.userData.phi)*Math.sin(spr.userData.theta);
    spr.position.y = spr.userData.radius*Math.cos(spr.userData.phi);
  });

  // update ảnh đồng bộ theo sprite chữ (với offset)
  imageGroup.children.forEach(img => {
    img.userData.theta += img.userData.speed;
    img.position.x = img.userData.radius*Math.sin(img.userData.phi)*Math.cos(img.userData.theta) + img.userData.offset;
    img.position.z = img.userData.radius*Math.sin(img.userData.phi)*Math.sin(img.userData.theta);
    img.position.y = img.userData.radius*Math.cos(img.userData.phi);
  });

  currentDist += .06*(targetDist - currentDist);
  const nx = Math.cos(rotX), ny = Math.sin(rotX), nz = Math.cos(rotY), nw = Math.sin(rotY);
  camera.position.set(currentDist*nw*nx, currentDist*ny, currentDist*nz*nx);
  camera.lookAt(0,0,0);
  renderer.render(scene, camera);
}
tick();

/* Resize handling */
addEventListener("resize", ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>